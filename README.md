# credit-score-web-pentest
Vulnerable credit score web app

OBJETIVO:

Limpiar el historial crediticio de una persona amiga (Bob), es decir, que todas sus transacciones aparezcan en estado “Pagado”.

Para lograr esto, tomaremos el control de la cuenta de Alice (una clienta cualquiera, para realizar el ataque desde una cuenta ajena), escalaremos privilegios para convertirnos en administradores, y forzaremos al servidor a realizar una acción sobre la API para modificar el estado de las transacciones de nuestra persona amiga.


PASO 1 - XSS

Le hacemos llegar a la víctima (Alice) un correo electrónico phishing que contiene un link a una página web maliciosa, la cual dentro del código HTML tiene código JavaScript que roba las cookies de sesión de la aplicación web vulnerable (financiera). Cuando Alice ingresa a la página web maliciosa, se ejecuta dicho código y se crea un archivo .txt en el servidor de la página web maliciosa llamado “stolen_cookies.txt” que contiene las cookies robadas.

Esto es posible ya que no se siguen prácticas recomendadas, como por ejemplo: escapar datos de salida antes de mostrarlos en HTML y usar cabeceras de seguridad de HTTP como CSP (content security policy).


*SUPUESTO*: la víctima debe estar logueada en la página web vulnerable (financiera) antes de ingresar a la página web maliciosa.


PASO 2 - Identification and authentication failures

Una vez que tenemos las cookies de sesión, abrimos una ventana en el navegador web e ingresamos a la cuenta de Alice en la aplicación web vulnerable (financiera) haciendo uso de las cookies robadas.

Esto es posible ya que no se utilizan flags de seguridad al configurar las cookies, como por ejemplo: HttpOnly, Secure y SameSite.


PASO 3 - SQL Injection

Una vez dentro de la cuenta de Alice, nuestro objetivo es escalar privilegios y convertirnos en administradores. Para eso, buscamos algún punto de entrada.
Nos dirigimos al apartado para modificar la información personal del usuario y probamos algunos inputs en el campo “Nombre”.

- Probamos ingresando el carácter ‘. Vemos que se ocasiona un error que revela información sensible como el tipo de la base de datos, el nombre de la tabla “usuarios”, el campo clave “username” con valor “alice” y la existencia de un campo “es_admin”con valor 0.
- Luego, probamos ingresando la sentencia Alice', es_admin = 1 WHERE username = 'alice' -- " . A simple vista parece que no sucedió nada, pero al volver al dashboard principal, ahora nos aparece el dashboard de los administradores. Hemos podido escalar privilegios.

Esto es posible ya que no se están utilizando buenas prácticas, como por ejemplo: uso de sentencias SQL preparadas, validación y sanitización de todas las entradas del usuario en el servidor, manejo de errores adecuado y evitar la construcción de consultas SQL concatenando cadenas.


PASO 4 - SSRF

Al poder acceder al dashboard de los administradores, vemos que hay un input para buscar el historial crediticio según el DNI ingresado. 
Realizamos la consulta usando el DNI de Bob, y analizamos el request con la ayuda de un proxy (en este caso, Burp). Podemos observar que existe un parámetro que se envía en el request llamado “url”, el cual contiene la ruta al servicio externo (API) con dos parámetros: “dni” (cuyo valor es el dni ingresado) y “limpiar” cuyo valor es por defecto “false”. Esto no da una pista del funcionamiento de la API, y podemos concluir en que modificando el valor del parámetro “limpiar” a “true” podremos limpiar el historial crediticio de Bob.
Por lo tanto, modificamos el valor del parámetro y enviamos nuevamente el request. Una vez hecho esto, volvemos a consultar el historial crediticio de Bob y vemos que todas sus transacciones ahora están en estado “Pagado”. Hemos podido lograr nuestro objetivo.

Esto es posible ya que no existe una configuración segura de los servicios utilizados y se siguen malas practicas de programacion.